다음 본문은 [실용주의 프로그래머](/) 책 내용을 정리한 것입니다!  
작성자가 `마음에 드는 Tip`들만 모아서 정리했으니 **참고** 바랄게요~!  

### 깨진 창문을 내버려두지 말라

`깨진 창문` : 나쁜 설계, 잘못된 결정, 형편없는 코드  
절대로 **깨진 창문**을 고치지 않은채로 내버려 두지 마라!  
분명 언젠가는 **레거시 코드**가 될 운명이며 이는 `리팩토링` 대상이 될 게 뻔하다!  


### 변화의 촉매가 되라

무엇을 해야 하는지, 어떻게 해야 하는지 정확히 아는 상황이 있다  
시스템이 옳다는 걸 알지만 더 개선해볼 수 있다는 것을 안다  
하지만 `시작 피로`가 너무 과한 나머지 망설여질 때가 많다  
그럴때일수록 **사람들에게 보여줘라**  
"만약 ~를 추가하기만 하면 더 나아지겠죠" 처럼 안중요한 듯이 은근슬쩍 말해보자  


### 지식 포트폴리오에 주기적으로 투자하라

여러분의 지식 자산에 들어갈 최선의 길들은 몇가지가 있다
* 매년 새로운 언어를 최소 하나는 배워라
* 기술 서적을 분기마다 한 권씩 읽어라
* 비 기술 서적도 읽어라
* 수업을 들어라
* 지역 사용자 모임에 참여하라 -> 회사 밖에서도 다른 사람들이 어떤일 하는지 알아보라
* 다른 환경에서 실험해보라 -> 윈도우를 회사에서 쓰면, 집에서는 맥을!
* 요즘 흐름을 놓치지 마라
* 인터넷을 이용하라

### 무엇을 말하는가와 어떻게 말하는가 모두 중요하다

우리는 많은 `동료 프로그래머들`과 함께 일한다  
그만큼 커뮤니케이션은 중요하니까 말하기전에 **무엇을 말할지** 다시 한번 생각해보자  
말할 주제가 정해졌으면 **전달력 있게 말하는 것**도 능력이다  


### DRY원칙을 지키고 재사용하기 쉽게 만들어라

`DRY` : Don't Repeat Yourself, 중복은 정말 해악이다  
의사소통이든 코드든 중복은 업무의 효율성을 방해하는 요소다  
재사용하기 쉽게 만든다는 것은 남에게 `쉽게 잘 전달`되도록 작성하라는 의미다!  
아무리 좋은 코드나 문서라도 남이 잘 읽지 못하면 아무런 쓸모가 없다  


### 최종 결정이란 없다

소비자들의 요구는 끊임없이 변화한다  
세상이 변하는 만큼 실세계를 바탕으로 구현한 SW도 마찬가지로 계속 변한다  
특정 조건에 `의존적`으로 구현하게 되면 **변화에 느리게 대응**할 수 밖에 없다  
그러므로 항상 유연하게 코드 짜는 연습을 해라  


### 코드와 함께 일정도 반복하며 조정하라

우리는 `기한`을 지켜서 프로그램을 만드는 프로그래머다  
정확한 일정을 맞춰서 제작하는 것은 많이 어려울뿐더러 못지키면 `신뢰`만 잃을 뿐이다  
주로 우리가 고려해야되는 항목은
* 요구사항 체크하기
* 위험 분석하기
* 설계, 구현, 통합
* 사용자와 함께 검증하기
위 4가지 항목을 일정한 `반복주기`로 끊임없이 고려해야한다  
아직 정확한 추정을 모르는데 누군가 자꾸 물어본다면
```text
나중에 전화드릴게요
```
라고 말해라  


### 비난 대신 문제를 해결하라

버그가 여러분의 잘못인지 다른 사람의 잘못인지는 그리 중요한게 아니다  
어쨌거나 그 버그는 여러분의 문제로 남는다  
다른 사람의 문제를 해결해보자  
만약 여러분이 `단 하나`를 변경했고 시스템이 멈춘다면 `그 하나`가 문제가 있는 것이다  


### 가정하지 마라. 증명하라

놀라운 버그를 마주치면, 단순히 그걸 고치는 것을 넘어서 왜 이 `실패`가 더 일찍 발견되지 않았을까  
생각해볼 필요가 있다!  
마주친 버그와 동일한 버그가 있을 여지가 있는 다른 코드를 더 살펴봐라!!  
그리고 `팀`과 함께 공유해라. **한 사람이 그랬다는 것은 다른 사람도 충분히 잘못 작성할 수 있다**  


### 일찍 작동을 멈추게 하라

시스템이 문제가 있다면 절대로 그것을 감싸지 말고 `예외`로 멈추게 해라  
문제가 있는 시스템을 **유지**한다는 것이 더 바보 같은 생각이다  


### 모듈간의 결합도를 최소화하라

`디미터 함수 법칙` = 이 법칙은 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다  
불필요한 **의존**이 많아질 수록 `시스템`은 **유지보수**하기 어렵다  

### 코드에는 추상화를, 메타데이터에는 세부 내용을

이렇게 하면 다음과 같은 이점이 있다
* 설계의 결합도를 줄여 좀 더 유연하고 적응성 있는 프로그램이 된다
* 세부사항을 코드 밖으로 몰아내서 강하고 추상적인 디자인을 만들 수 있다
* 애플리케이션을 커스터마이징 하기 위해 다시 컴파일할 필요가 없다
* 메타데이터는 범용 프로그래밍 언어보다 문제 도메인에 가까운 방식으로 표현할 수 있다
